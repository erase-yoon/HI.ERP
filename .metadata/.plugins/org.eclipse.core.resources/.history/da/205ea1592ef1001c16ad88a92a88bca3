package com.google.erp;

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// 직원 정보를 관리하는 [Employee] 클래스 선언하기
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
public class Employee {
	
	// mmmmmmmmmmmmmmmmmmmm
	// 속성변수 선언하기
	// mmmmmmmmmmmmmmmmmmmm
	
	// ------------------------------------------------ 
	// [직원번호]가 저장되는
	// int 형 속성변수 [emp_no]을 선언하기
	// ------------------------------------------------
	// public | protected | default | private [static] [final] 기본자료형|클래스명|인터페이스명 속성변수명 [= 데이터];
	private int emp_no;
	
	// ------------------------------------------------ 
	// [직원명]이 저장되는
	// String 형 속성변수 [emp_name]을 선언하기
	// ------------------------------------------------
	// private [static] [final] 기본자료형 속성변수명 [= 데이터];
	private String emp_name;
	
	// ------------------------------------------------ 
	// Dept 객체의 메모리 위치 주소 값이 저장 예정인
	// 참조형 속성변수 [dept]를 선언하기
	// ------------------------------------------------
	// private [static] [final] 클래스명 속성변수명 [= 데이터];
	private Dept dept;
	
	
	
	// mmmmmmmmmmmmmmmmmmmm
	// 생성자 선언하기
	// mmmmmmmmmmmmmmmmmmmm
	
	// ------------------------------------------------
	// public | protected | default | private 생성자명 ([자료형 매개변수, ~]]){ 실행구문; }
	public Employee (int emp_no, String emp_name, Dept dept) {
		
		// ------------------------------------------------ 
		// 속성변수에 생성자의 매개변수로 들어온 데이터를 저장하기
		// ------------------------------------------------
		this.emp_no = emp_no;
		this.emp_name = emp_name;
		this.dept = dept;
	}
	
	
	// mmmmmmmmmmmmmmmmmmmm
	// 메소드 선언하기
	// mmmmmmmmmmmmmmmmmmmm
	
	// ------------------------------------------------ 
	// [직원번호]를 리턴하는 메소드 선언하기
	// ------------------------------------------------
	// public | protected | default | private [static] [final / abstract] 기본자료형 | 클래스명 | 인터페이스명 | void	메소드명([자료형 매개변수, ~]]){ 실행구문; }
	public int getEmp_no() {
		// 속성변수 emp_no의 데이터를 리턴하기
		return emp_no;
	}
	
	// ------------------------------------------------ 
	// [직원명]을 리턴하는 메소드 선언하기
	// ------------------------------------------------
	// public | protected | default | private [static] [final / abstract] 기본자료형 | 클래스명 | 인터페이스명 | void	메소드명([자료형 매개변수, ~]]){ 실행구문; }
	public String getEmp_name() {
		// 속성변수 emp_name의 데이터를 리턴하기
		return emp_name;
	}
	
	// ------------------------------------------------ 
	// [직원번호]를 수정하는 메소드 선언하기
	// ------------------------------------------------
	public void setEmp_no(int emp_no) {
		this.emp_no = emp_no;
	}
		
	// ------------------------------------------------ 
	// [직원명]을 수정하는 메소드 선언하기
	// ------------------------------------------------
	public void setEmp_name(String emp_name) {
		this.emp_name = emp_name;
	}
	
	// ------------------------------------------------ 
	// [Dept 객체]의 메모리 위치 주소 값을 리턴하는 메소드 선언하기
	// ------------------------------------------------
	public Dept getDept() {
		return dept;
	}
	
	// ------------------------------------------------ 
	// [Dept 객체]의 메모리 위치 주소 값을 수정하는 메소드 선언하기
	// ------------------------------------------------
	public void setDept(Dept dept) {
		this.dept = dept;
	}

}
/*
 * 
 * ----------------------------------------------------------------
 * <문제> 생성자 public Employee(~){~}를 주석 처리한다면? 즉 없애면?
 * ----------------------------------------------------------------
 * 생성자는 코딩상 0개 이상이다.
 * 만약 0개면 즉 아무것도 선언하지 않으면 기본생성자인
 * public 생성자명(){}이 삽입된다.
 * 위 예제에서는 생성자가 0개면 public Employee(){}가 삽입된다.
 * ---------------------------------------------------------------
 * Employee 클래스에서는 에러는 없다.
 * 
 * com.google.erp.EmployeeExe 클래스의
 * Employee employee = new Employee(1, "사오정");
 * 에서 에러가 발생한다.
 * 생성자 호출 코딩 Employee(1, "사오정")을 받아들이는 클래스가 없다.
 * 
 * ----------------------------------------------------------------
 * <문제> 아래 처럼 코딩을 수정하면?
 * ----------------------------------------------------------------
 * 
 * --------------------------------------------------------
 * public int getEmp_no(){
 * 	return emp_no;
 * }
 * --------------------------------------------------------
 * 				⇩
 * --------------------------------------------------------
 * public double getEmp_no(){
 * 	return emp_no;
 * }
 * --------------------------------------------------------
 * 에러가 없다.
 * 
 * return emp_no;에서 emp_no 변수 안의 데이터를 리턴한다는 뜻이다.
 * emp_no 변수 안의 데이터 자료형은 int 형이다.
 * 메소드 왼쪽에 리턴 자료형과 실제 리턴하는 데이터의 자료형이 맞지 않는다.
 * 실제 리턴 데이터 int가 double로 변환된다.
 * 결국 직원번호가 실수로 바뀌어 리턴된다.
 * 
 * ----------------------------------------------------------------
 * <문제> 아래 처럼 코딩을 수정하면?
 * ----------------------------------------------------------------
 * 
 * --------------------------------------------------------
 * public int getEmp_no(){
 * 	return emp_no;
 * }
 * --------------------------------------------------------
 * 				⇩
 * --------------------------------------------------------
 * public void getEmp_no(){
 * 	return emp_no;
 * }
 * --------------------------------------------------------
 * 에러가 발생한다.
 * 메소드 왼쪽의 void는 메소드 안의 코딩에서 리턴되는 없다라는 의미이다.
 * 그런데 메소드 안에서 return emp_no;에 의해 데이터가 리턴되고 있어서 에러가 발생한다.
 * 즉 메소드의 리턴 자료형과 실제 리턴되는 데이터의 자료형이 안맞는다.
 * 
 * ----------------------------------------------------------------
 * <문제> private String emp_name; 에서 속성변수를 선언하고 데이터를 저장하지는 않았다.
 * 즉 속성변수를 선언만 하고 데이터를 저장하지 않으면 속성변수 안에는 정말 아무 데이터도 없는가?
 * ----------------------------------------------------------------
 * 속성변수를 선언만 하고 데이터를 저장하지 않으면
 * 자바는 디폴트 값을 자동으로 넣어준다.
 * 왜? 속성변수는 객체를 구성하는 중요한 멤버이기 때문에 대우를 해준다.
 * 속성변수가 자료형이 byte, short, int, long이면 디폴트로 0을 넣어준다.
 * 속성변수가 자료형이 float, double이면 디폴트로 0.0을 넣어준다.
 * 속성변수가 자료형이 boolean이면 디폴트로 false을 넣어준다.
 * ----------------------------------------------------------------
 * 속성변수가 자료형이 참조형이면 디폴트로 null을 넣어준다.
 * 
 * <참고> null 이란?
 * 객체의 메모리 위치 주소 값이 아직은 없다.
 * 추후에 들어갈 예정.
 * 일종의 더미 데이터이다.
 * null도 데이터 취급한다. 참조형 취급한다.
 * 더미 = 형체만 있고 기능은 없는 대상물.
 * 
 * 
 * ----------------------------------------------------------------
 * <문제> 아래 처럼 코딩을 수정하면?
 * ----------------------------------------------------------------
 * 
 * --------------------------------------------------------
 * public String getEmp_name(){
 * 	return emp_name;
 * }
 * --------------------------------------------------------
 * 				⇩
 * --------------------------------------------------------
 * public String getEmp_name(){
 * 	// return emp_no;
 * }
 * --------------------------------------------------------
 * 에러가 발생한다.
 * 메소드 왼쪽의 String은 메소드 안의 코딩에서 리턴되는 데이터는 String 형이다라는 의미이다.
 * 그런데 메소드 안에서 return 문자;가 없어서 에러가 발생한다.
 * 즉 메소드의 리턴 자료형은 String인테 실제 리턴되는 데이터는 없어서 에러.
 * 
 * ----------------------------------------------------------------
 * <문제> return emp_name;의 의미는?
 * ----------------------------------------------------------------
 * return 데이터 또는 변수;
 * 	return 오른쪽에 데이터 또는 변수안의 데이터를 리턴하고 메소드는 중단하라
 * 	return 오른쪽의 데이터 자료형과 메소드명 왼쪽의 리턴 자료형이 일치해야 한다.
 * ------------------
 * <주의> return;
 * ------------------
 * 	메소드를 중단하라
 * 	return; 이 있으면 메소드명 왼쪽에 void가 나와야 한다.
 * 	  
 * ========================================================================
 * 메소드의 실행구문에서		메소드명 왼쪽 리턴자료형
 * ========================================================================
 * return 실수형;				~ double 메소드명(~){~}
 * return 정수형;				~ int|double 메소드명(~){~}
 * return boolean형;			~ boolean 메소드명(~){~}
 * return '문자하나';			~ char 메소드명(~){~}
 * return "문자";				~ String 메소드명(~){~}
 * return 객체의 메위주;		~ 객체의 전신 클래스명 메소드명(~){~}
 * return;						~ void 메소드명(~){~}
 * 
 * ------------------------------------------------------------------------
 * <주의> 하나의 메소드 안에서 return 데이터;와 return;가 동시에 나올 수 있나?
 * ------------------------------------------------------------------------
 * 불가능하다.
 * 
 * ----------
 * 새끼문제
 * ----------
 * public String xxx(){		: 에러발생.String을 void로 고치면 된다.
 * 	return
 * }
 * 
 * public String xxx(){		: 에러없음.null도 참조형 취급한다.
 * 	return null;
 * }
 * 
 * ----------
 * 구문 정지
 * ----------
 * 반복문 -> break
 * switch문 -> break
 * 메소드 -> return
 * if문 -> 없음
 * 
 * ----------------------------------------------------------------
 * <문제> public Employee(int emp_no, String emp_name) {~} 코딩 밑에
 * public Employee(){~} 를 추가 가능한가?
 * ----------------------------------------------------------------
 * 가능하다.
 * 생성자는 0개 이상 코딩이 가능하다.
 * 단 생성자가 2개이상 일때는 생성자의 매개변수 개수가 다르거나 개수가 같으면 자료형이 달라야한다.
 * 생성자 오버로딩(constructor overloading)이라고 부른다.
 * 
 * 생성자 오버로딩(constructor overloading) 규칙
 * 생성자명이 클래스명과 동일해야한다.
 * 생성자 앞에는 리턴형이 없어야한다.
 * 생성자의 매개변수 개수가 다르거나 개수가 같으면 자료형이 달라야한다.
 * 
 * ----------------------------------------------------------------
 * <문제> public Employee(int emp_no, String emp_name) {~} 코딩 밑에
 * public Employee(int emp_no2, String emp_name2){~} 를 추가 가능한가?
 * ----------------------------------------------------------------
 * 불가능하다.
 * 생성자 오버로딩 규칙에 위반된다.(매개변수 개수와 자료형이 같음)
 * 
 * ----------------------------------------------------------------
 * <문제> public Employee(int emp_no, String emp_name) {~} 코딩 밑에
 * public Employee(String emp_name, int emp_no){~} 를 추가 가능한가?
 * ----------------------------------------------------------------
 * 가능하다.
 * 
 * ----------------------------------------------------------------
 * <문제> private String emp_name;을 
 * private final String emp_name;로 수정 가능한가?
 * ----------------------------------------------------------------
 * 수정 불가(에러 발생)
 * 
 * 발생 지점 : this.emp_name = emp_name;
 * 발생 이유 : final이 붙은 속성변수는 초기화 후 갱신이 불가능한데 
 * this.emp_name = emp_name;에서 데이터 갱신을 시도하고 있다.
 * 
 * <주의> 속성변수는 선언 후에 초기화하지 않으면 자동 초기화된다.
 * 즉 선언 후에 데이터를 저장하지 않으면 기본값을 넣어준다.
 * 그만큼 중요한 멤버이기 때문이다.
 * 단 예외적으로 final 붙은 속성변수는 개발자가 초기화하지 않으면 자동초기화 되지 않는다.
 * 그러므로 final 붙은 속성변수는 선언하자마자 초기화해주던가
 * 아니면 생성자 안에서 초기화 해주어야한다.
 * 
 * ----------------------------------------------------------------
 * <문제> 위 Employee 클래스를 [클래스 다이어그램]으로 표시하면?
 * ----------------------------------------------------------------
 * ※ 클래스 다이어그램 :  클래스 구조를 표 형식으로 표현한 것. 프로젝트 산출물에 삽입된다.
 * 
 * ----------------------------------------------
 * com.google.erp.Employee
 * ----------------------------------------------
 * -emp_no : int
 * -emp_name : String
 * ----------------------------------------------
 * +Employee(emp_no : int, emp_name : String)
 * ----------------------------------------------
 * +getEmp_no() : int
 * +setEmp_no(emp_no : int) : void
 * +getEmp_name() : String
 * +setEmp_name(emp_name : String) : void
 * 
 * ----------------------------------------------------------------
 * <문제> 다음 중 생성자 오버 로딩이 잘못된 것을 고르시오.
 * ----------------------------------------------------------------
 * public class Bank {
 * public Bank() {}
 * public Bank(int money) {}
 * public Bank(double money) {}
 * public Bank(int money, String account) {} 
 * public void Bank(String account, int money) {}	// Error
 * public Bank(int money2, String account2) {}	// Error
 * 
 * ----------------------------------------------------------------
 * <문제> 다음 중 메소드 오버 로딩이 잘못된 것을 고르시오.
 * ----------------------------------------------------------------
 * public class Bank {
 * public int getMoney() { ~ }
 * public int getMoney(int money) { ~ }
 * public int getMoney(double money) { ~ }
 * public int getMoney(int money, String account) { ~ } 
 * public int getMoney(String account, int money) { ~ }
 * public int getMoney(int money2, String account2) { ~ }	// Error
 * 
 * 메소드 오버 로딩 규칙
 * 메소드 명이 동일해야 한다.
 * 매개변수의 개수가 다르거나 개수가 같다면 자료형이 달라야 한다.
 */