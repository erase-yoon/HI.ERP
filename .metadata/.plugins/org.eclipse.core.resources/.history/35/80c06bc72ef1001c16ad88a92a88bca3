// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// 소속 패키지 선언하기
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
package com.google.erp;

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// 은행 정보를 관리하는 [KBank] 클래스 선언하기
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
public class KBank {
	
	// mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
    // 속성변수 선언하기
    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
	
	// nnnnnnnnnnnnnnnnnnnnnnn
    // [저금액] 저장되는
    // int 형 속성변수 [money] 선언하기 
    // <주의>int 형 속성변수 선언 후 수동 초기화가 없으면 디폴트 값으로 0 로 자동 초기화됨. 
    // nnnnnnnnnnnnnnnnnnnnnnn
	private static int money;
	
	// nnnnnnnnnnnnnnnnnnnnnnn
    // 입금 또는 출금 시 경고 문자 저장하는 속성변수 선언 
    // nnnnnnnnnnnnnnnnnnnnnnn
	public static String msg = "";
	
    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
    // 생성자 선언하기
	// <주의> 생성자는 리턴형이 없다. 그러므로 생성자 내부에 return 데이터; 가 나오면 안된다.
    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
	
	// nnnnnnnnnnnnnnnnnnnnnnn
    // 매개변수로 돈이 들어오는 생성자 선언하기 
    // nnnnnnnnnnnnnnnnnnnnnnn
	public KBank(int money) {
		// ***********************************************************************
        // 생성자 호출 시 매개변수로 들어온 데이터를 속성변수에 저장하기.
        // 속성변수명과 생성자 매개변수명이 동일하면 속성변수는 this.속성변수명 으로 사용함.
        // ***********************************************************************
		this.money = this.money + money;
	}
	
	// nnnnnnnnnnnnnnnnnnnnnnn
    // 매개변수가 없는 생성자 선언하기 
    // nnnnnnnnnnnnnnnnnnnnnnn
	public KBank() {
		// ***********************************************************************
        // 동료 생성자를 KBank(100);으로 호출하기
        // ***********************************************************************
		this(0);
		
	}
	
    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
    // 메소드 선언하기
    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
	// nnnnnnnnnnnnnnnnnnnnnnn
    // [저금액] 리턴하는 메소드 선언하기
    // nnnnnnnnnnnnnnnnnnnnnnn
	public int getMoney() {
		// ***********************************************************************
        // 속성변수 money의 데이터를 리턴하기
        // ***********************************************************************
		return money;
	}

    // nnnnnnnnnnnnnnnnnnnnnnn
    // 입금하는 메소드 선언하기
    // nnnnnnnnnnnnnnnnnnnnnnn
	public void add(int money) {
		// ***********************************************************************
		// 메소드 호출 시 매개변수 money로 들어온 데이터를 속성변수 money에 [누적]하여 저장하기
		// this. 뒤의 변수는 속성변수명이다.
		// 속성변수 money 와 매개변수 money 이 동일하므로 헷갈리지 않기 위해 this. 을 붙인다.
		// ***********************************************************************
		this.money = this.money + money;
		System.out.println("입금 성공, 입금액 : " + money);
		// 아래 코딩은 위 코딩과 동일하다.
		// this.money += money;
		
		msg = msg + " 입금 성공, 입금액 : " + money;
	}
	
    // nnnnnnnnnnnnnnnnnnnnnnn
    // 출금하는 메소드 선언하기
    // nnnnnnnnnnnnnnnnnnnnnnn
	public void minus(int money) {
		// ***********************************************************************
        // 만약 출금액이 총액보다 같거나 작으면
        // ***********************************************************************
		if(this.money >= money) {
			this.money = this.money - money;
			// 아래 코딩은 위 코딩과 동일하다.
			// this.money -= money;
			System.out.println("출금 성공, 출금액 : " + money);
			
			msg = msg + " 출금 성공, 출금액 : " + money;	
		}
		// ***********************************************************************
        // 만약 출금액이 총액보다 크면
        // ***********************************************************************
		else {
		// else if(this.money < money) {
		// if(this.money < money) {
			System.out.println("출금 실패 : 출금액이 원금보다 큽니다.");
			
			msg = msg + "출금 실패 : 출금액이 원금보다 큽니다.";

		}

	}

}

/*
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> public class KBank{ ~ } 를 public final class KBank{ ~ } 로 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 없음
 * ---------------------------------------------------------------
 * final이 붙은 클래스는 타 클래스가 부모 클래스가 되어 달라고 요청하면 거절할 수 있다.
 * 즉 자식 클래스를 가질 수 없다.
 * ---------------------------------------------------------------
 * 
 * ---------------------------------------------------------------
 * public class Xxx { ~ }
 * public class Yyy extends Xxx { ~ }		O
 * ---------------------------------------------------------------
 * ---------------------------------------------------------------
 * public final class Xxx { ~ }
 * public class Yyy extends Xxx { ~ }		X
 * ---------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> public class KBank{ ~ } 를 public abstract class KBank{ ~ } 로 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 없음
 * ---------------------------------------------------------------
 * abstract가 붙은 클래스는 new에 의한 객체화가 불가능하다.
 * 즉 타 클래스 내부에서 new에 의한 객체화 시도가 불가능하다.
 * ---------------------------------------------------------------
 * ******************************************
 * 클래스 이름 앞에 abstract 를 붙이는 경우
 * ******************************************
 * ---------------------------------------------------------------
 * <1> {~}가 없는 메소드를 소유한 경우
 * ---------------------------------------------------------------
 * <2> 조상 클래스 중 {~}가 없는 메소드를 소유하고 있고 그 후손 클래스 중
 * 		{~}가 없는 메소드를 재정의(overriding) 하지 않은 경우.
 * 		상속 배울 때 자세히 이야기 함.
 * ---------------------------------------------------------------
 * <3> <1>도 아니고 <1>도 아닌 경우.
 * 		그냥 객체화를 막기 위함이다.
 * ---------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> private int money; 를 private char money; 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 발생.
 * ---------------------------------------------------------------
 * char 형으로 선언되는 속성변수에는 char 형의 문자가 저장되야한다.
 * 저장하는 문자형이 char형이 아닌 곳에서 에러가 발생한다.
 * -------------
 * 에러 발생 지점
 * -------------
 * 생성자 내부에서 this.money = money; 에 의해 int 형이 저장되고 있다.
 * 메소드 내부에서 this.money = this.money + money; 에 의해 int 형이 저장되고 있다.
 * 메소드 내부에서 this.money = this.money - money; 에 의해 int 형이 저장되고 있다.
 * ---------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> private int money; 를 private final int money; 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 발생.
 * ---------------------------------------------------------------
 * 갱신을 시도하는 곳에서 에러가 발생한다.
 * -------------
 * 에러 발생 지점
 * -------------
 * this.money = this.money + money;
 * this.money = this.money - money;
 * <주의> 생성자 안의 this.money = money;는 에러 부분이 아니다. 
 * 	갱신이 아니라 초기화이기 때문이다.
 * 
 * ******************************
 * final 이 붙는 속성변수의 특징
 * ******************************
 * -------------------------------------------------------------
 * 자동 초기화가 되지 않는다.
 * -------------------------------------------------------------
 * <참고> final이 없는 속성변수는 수동 초기화가 없으면 자동 초기화된다.
 * -------------------------------------------------------------
 * 자동 초기화가 되지 않으므로 선언 시 수동 초기화하던가
 * 생성자 안에서 수동 초기화 해야한다.
 * -------------------------------------------------------------
 * 데이터 갱신이 불가능하다. final 은 초기화 후에 갱신하지 말하는 의미이다.
 * -------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> private int money; 다음에 private double money;를 삽입하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 발생.
 * ---------------------------------------------------------------
 * 동일한 클래스 내부에 동일한 이름의 속성변수는 허용되지 않는다.
 * 호출 시 어떤 속성변수를 사용해야 할 지 모르므로 안된다.
 * -------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> 생성자가 public KBank( int money ){~} 와 public KBank(  ){~} 인데
 * 생성자가 2개 이상이어도 되는가?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 생성자가 2개 이상이면 생성자 overloading이라고 한다.
 * 필요에 따라 골라 호출하라는 의미이다.
 * ---------------------------------------------------------------
 * 단 아래 생성자 overloading 규칙을 지켜야 한다.
 * ---------------------------------------------------------------
 * 
 * -----------------------------
 * 메소드 overloading 규칙
 * -----------------------------
 * 생성자 명은 클래스명과 동일해야 한다.
 * 생성자끼리는 매개변수 개수가 달라야 한다.
 * 생성자끼리는 매개변수 개수가 같으면 대응하는 매개변수의 자료형이 달라야 한다.
 * ---------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> 생성자 public KBank( int money ){~} 와 public KBank( ){~} 를
 * 모두 주석 처리하여 생략하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 발생 없음.
 * ---------------------------------------------------------------
 * 생성자가 코딩 상 0개면 실행 시 기본 생성자 public 클래스명(){}을 넣어준다.
 * ---------------------------------------------------------------
 * 여기서는 public KBank(){}가 자동 삽입된다.
 * ---------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> public int getMoney( ){~} 를 public void getMoney( ){~} 로 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * --------------------------------------------------------------------
 * 에러 발생.
 * --------------------------------------------------------------------
 * getMoney 메소드 내부에  return money; 로 인하여 메소드의 리턴자료형은
 * 변수 money 의 자료형과 동일해야한다.
 * void 는 메소드 내에서 리턴하는 데이터가 없다는 뜻이므로 에러가 발생한다.
 * 즉 메소드의 리턴형이 void 라면 메소드 내부에는 return 데이터; 코딩이 나오면 안된다.
 * --------------------------------------------------------------------
 * <참고> return 데이터;  의미
 * --------------------------------------------------------------------
 * 메소드를 중단하고, 메소드를 호출한 대상한테 데이터를 리턴해주라는 의미
 * --------------------------------------------------------------------
 * <참고> return;  의미
 * --------------------------------------------------------------------
 * 메소드를 중단하라는 의미
 * --------------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> public int getMoney( ){~} 를 public double getMoney( ){~} 로 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * ---------------------------------------------------------------
 * 에러 발생 없음.
 * ---------------------------------------------------------------
 * 메소드의 리턴형과 메소드 내부의 리턴 데이터 자료형이 일치하지 않으면 에러가 발생한다.
 * --------------------------------------------------------------------
 * 그러나 아래 경우는 예외적으로 에러 발생이 없다.
 * --------------------------------------------------------------------
 * 		--------------------------------------------------------------------
 * 		~int	메소드명(~){ ~; return byte|short데이터; }
 * 		--------------------------------------------------------------------
 * 		~long	메소드명(~){ ~; return byte|short|int데이터; }
 * 		--------------------------------------------------------------------
 * 		~double	메소드명(~){ ~; return byte|short|int|long|float데이터; }
 * 		--------------------------------------------------------------------
 * 		~ 슈퍼클래스명	메소드명(~){ ~; return 슈퍼클래스후손클래스의 객체 메모리 위치 주소 값; }
 * 		--------------------------------------------------------------------
 * 				-----------     -----------
 * 				A 클              D 클
 * 				-----------     -----------
 * 				 |
 * 				-----------
 * 				B  클
 * 				-----------
 * 				 |
 * 				-----------
 * 				C 클
 * 				-----------
 * 
 * 		~ A  xxx(~){ ~; return A클래스의 객체 메모리 위치 주소 값; }   => 0
 * 		~ A  xxx(~){ ~; return B클래스의 객체 메모리 위치 주소 값; }   => 0
 * 		~ A  xxx(~){ ~; return C클래스의 객체 메모리 위치 주소 값; }   => 0
 * 		~ B  xxx(~){ ~; return B클래스의 객체 메모리 위치 주소 값; }   => 0
 * 		~ B  xxx(~){ ~; return C클래스의 객체 메모리 위치 주소 값; }   => 0
 * 
 * 		~ B  xxx(~){ ~; return A클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 		~ C  xxx(~){ ~; return A클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 		~ C  xxx(~){ ~; return B클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 
 * 		~ D  xxx(~){ ~; return A클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 		~ D  xxx(~){ ~; return B클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 		~ D  xxx(~){ ~; return C클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 
 * 		~ A  xxx(~){ ~; return D클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 		~ B  xxx(~){ ~; return D클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 		~ C  xxx(~){ ~; return D클래스의 객체 메모리 위치 주소 값; }   => X (에러 발생)
 * 
 * 		--------------------------------------------------------------------
 * 		~ 인터페이스명	메소드명(~){ ~; return 인터페이스를 구현클래스의 객체 메모리 위치 주소 값; }
 * 		--------------------------------------------------------------------
 * 		~ 클래스명	메소드명(~){ ~; return null; }
 * 		--------------------------------------------------------------------
 * 		~ 인터페이스명	메소드명(~){ ~; return null; }
 * 		--------------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> public void add(int money){~} 를 public int add(int money){~} 로 수정하면?
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * --------------------------------------------------------------------
 * 에러 발생.
 * --------------------------------------------------------------------
 * 메소드의 리턴자료형은 메소드 내에서 리턴하는 데이터의 자료형과 일치해야한다.
 * --------------------------------------------------------------------
 * 메소드의 리턴자료형이 int 이므로 메소드 내에서
 * return int형데이터;  코딩이 나와야 하는데 없다.
 * --------------------------------------------------------------------
 * 
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * <문> public void add(int money){~} 다음에 아래 코딩을 삽입하면?
 * 		public void add( int money1, int money2 ){
 * 			this.money = this.money + money1 + money2;
 * 		}
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * --------------------------------------------------------------------
 * 에러 발생 없음.
 * --------------------------------------------------------------------
 * 동일한 이름의 메소드가 2개 이상이면 [메소드 overloading] 이라고 한다.
 * --------------------------------------------------------------
 * 단 아래 메소드 overloading 규칙을 지켜야 한다.
 * --------------------------------------------------------------
 * -----------------------------
 * 메소드 overloading 규칙
 * -----------------------------
 * 메소드명이 서로 동일해야한다.
 * 메소드 끼리는 매개변수 개수가 달라야한다.
 * 메소드 끼리는 매개변수 개수가 같으면 대응하는 매개변수의 자료형이 달라야한다.
 */